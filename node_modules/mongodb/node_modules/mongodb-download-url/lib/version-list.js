"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearCache = exports.getVersion = void 0;
const zlib_1 = __importDefault(require("zlib"));
const fs_1 = require("fs");
const util_1 = require("util");
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const semver_1 = __importDefault(require("semver"));
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default('mongodb-download-url:version-list');
const gunzip = util_1.promisify(zlib_1.default.gunzip);
const gzip = util_1.promisify(zlib_1.default.gzip);
function defaultCachePath() {
    return path_1.default.join(os_1.default.tmpdir(), '.mongodb-full.json.gz');
}
let fullJSON;
let fullJSONFetchTime = 0;
async function getFullJSON(opts) {
    var _a, _b, _c;
    const versionListUrl = (_a = opts.versionListUrl) !== null && _a !== void 0 ? _a : 'https://downloads.mongodb.org/full.json';
    const cachePath = (_b = opts.cachePath) !== null && _b !== void 0 ? _b : defaultCachePath();
    const cacheTimeMs = (_c = opts.cacheTimeMs) !== null && _c !== void 0 ? _c : 24 * 3600 * 1000;
    let tryWriteCache = cacheTimeMs > 0;
    const inMemoryCopyUpToDate = () => fullJSONFetchTime >= new Date().getTime() - cacheTimeMs;
    try {
        if ((!fullJSON || !inMemoryCopyUpToDate()) && cacheTimeMs > 0) {
            debug('trying to load versions from cache', cachePath);
            const fh = await fs_1.promises.open(cachePath, 'r');
            try {
                const stat = await fh.stat();
                if (process.getuid && (stat.uid !== process.getuid() || (stat.mode & 0o022) !== 0)) {
                    tryWriteCache = false;
                    debug('cannot use cache because it is not a file or we do not own it');
                    throw new Error();
                }
                if (stat.mtime.getTime() < new Date().getTime() - cacheTimeMs) {
                    debug('cache is outdated');
                    throw new Error();
                }
                debug('cache up-to-date');
                tryWriteCache = false;
                fullJSON = JSON.parse((await gunzip(await fh.readFile())).toString());
                fullJSONFetchTime = new Date().getTime();
            }
            finally {
                await fh.close();
            }
        }
    }
    catch (_d) { }
    if (!fullJSON || !inMemoryCopyUpToDate()) {
        debug('trying to load versions from source', versionListUrl);
        const response = await node_fetch_1.default(versionListUrl);
        if (!response.ok) {
            throw new Error(`Could not get mongodb versions from ${versionListUrl}: ${response.statusText}`);
        }
        fullJSON = await response.json();
        fullJSONFetchTime = new Date().getTime();
        if (tryWriteCache) {
            const partialFilePath = cachePath + `.partial.${process.pid}`;
            await fs_1.promises.mkdir(path_1.default.dirname(cachePath), { recursive: true });
            try {
                const compressed = await gzip(JSON.stringify(fullJSON), { level: 9 });
                await fs_1.promises.writeFile(partialFilePath, compressed, { mode: 0o644, flag: 'wx' });
                await fs_1.promises.rename(partialFilePath, cachePath);
                debug('wrote cache', cachePath);
            }
            catch (_e) {
                try {
                    await fs_1.promises.unlink(partialFilePath);
                }
                catch (_f) { }
            }
        }
    }
    return fullJSON;
}
async function getVersion(opts) {
    const fullJSON = await getFullJSON(opts);
    let versions = fullJSON.versions;
    versions = versions.filter((info) => info.downloads.length > 0);
    if (opts.productionOnly) {
        versions = versions.filter((info) => info.production_release);
    }
    if (opts.version && opts.version !== '*') {
        versions = versions.filter((info) => semver_1.default.satisfies(info.version, opts.version));
    }
    versions = versions.sort((a, b) => semver_1.default.rcompare(a.version, b.version));
    return versions[0];
}
exports.getVersion = getVersion;
async function clearCache(cachePath) {
    debug('clearing cache');
    fullJSON = undefined;
    fullJSONFetchTime = 0;
    if (cachePath !== '') {
        try {
            await fs_1.promises.unlink(cachePath !== null && cachePath !== void 0 ? cachePath : defaultCachePath());
        }
        catch (err) {
            if (err.code === 'ENOENT')
                return;
            throw err;
        }
    }
}
exports.clearCache = clearCache;
//# sourceMappingURL=version-list.js.map